# ipbm: In-situ Progrmmable Behavioral Model

This software behavioral model comprises of two parts: software switch model that simulates hardware behavior and network topologies. Here we designed three use cases, named `mpls`, `ecmp` and `multi-tenant`, respectively.

# Prerequisites

- This project is built on Ubuntu 18.04 OS, and has not been verified for other systems.
- Before running the project, please be sure to check whether there are `mininet`, `grpc`, `protobuf`, and a series of required dependencies on your computer. [grpc](https://github.com/grpc/grpc), [pcap](https://www.tcpdump.org/).
- Be sure to check whether the CMakeLists file of this project matches your server configuration before building, and pay attention to configure your Cmake according to your own machine properly.
- Due to the large output of this project, multiple windows may need to be opened. Please note that there are at least four windows for observing the output.
- Although the two modules are independent, `walker_mininet` is highly coupled to `sw_dataplane` on the path, and the two modules can be moved as a whole. However, unless you know where the dataplane is referenced in the code, it is recommended not to move the code at will.

# Run

1. open `mininet` to build the network topology.
```
cd walker_mininet
```

and choose one use case to run, e.g., `mpls`, the corresponding command is:
```
make mininet uc=mpls
```
and you can modify `uc=xxx` to build other use case topologies.

2. Open a new terminal, build the data plane (software behavioral model).
```
cd walker_mininet
make data_plane uc=mpls
```
When the command ends, this window is used to create a switch and observe the output of the switch. Normally, the output of the switch should be the switch path that the packet passes through.
The path is the output of multiple switches, not a single switch. But before the configuration is delivered, the switch is silent.

3. Open another new terminal, build the control plane
```
cd walker_mininet
make controller uc=mpls
```
This window is used to view the output of the controller, and the controller outputs specific results of some algorithms and allocation.

4. Open another new terminal as the actual operating window for initializing and updating the switch.
```
cd walker_mininet
make init uc=mpls
```
This action implements initialization of the configuration and flow table for all switches in this example. Under normal circumstances, the controller and the data plane will display the operation output. If the mininet is pinging, all of them can be pinged normally, and the path information of each ping packet will be output in the data plane window. If it is not correct, for example `Segmentation error`, or `no response`, please check whether the delivered configuration is correct. If it is a `segment error`, it means that the delivered configuration is wrong, and if there is `no response`, it means that the configuration has not been delivered, maybe the controller is faulty, or maybe there is a problem with the file path.

5. After the output is stable, you can directly enter the next update command.
```
make update uc=mpls
```
This action updates the configuration and flow tables of all the switches in this example. Under normal circumstances, the controller and the data plane will display the output, and if it is pinging, the behavior of the data plane will change. For the specific change process, refer to the output log.

6. For another two use cases
- `ecmp`: you just need to modify `mpls` with `ecmp` for all `make` command,
- `multi_tenant`: it is rather complicated. The packet sending of `multi_tenant` is not done by `ping`, but by calling the python script through the make command.
```
make send1 uc=multi_tenant
make send2 uc=multi_tenant
make send3 uc=multi_tenant
```

# Attention: Code Description

- The dataplane code needs to accept a `yaml` file that records the interface of each port to determine which node of the network the switch is installed on. In addition, a `grpc` port is required as the port to accept the controller configuration and flow table. The `yaml` file is located in the interface of `walker_mininet`. When starting a virtual machine, directly pass the path of the corresponding `yaml` file into the program as a parameter.

- The `json` of the flow table issued by the controller is in the `entry` folder of `walker_mininet`. These jsons are generated by code, not handwritten. The code file is in **walker_mininet/walker_mininet/[use_case_name]/[use_case_name]_build_entry.py**. It is not json that is finally passed into the data plane, and the json is written for convenience.
In addition to the various digital addresses in this code, the file structure is still easy to understand. If there is a problem with the flow table, maybe there is a problem with the value given in it.

- The json sent by the controller should be compiled and generated. Please refer to the [main](https://github.com/jijinfanhua/IPSA-ipbm) for the compiler. The controller scans the folder every second to see if there are any files sent in by the python script. If there are files, the controller will be started to compile and then the updated configuration is sent to the dataplane. If not, continue to scan.

- For mininet, it builds the network topology through the topology file, which is located in the `topology` folder. Different use cases call different topology files, and they are divided into two files: before update and after update. The content of the two files differs only in the flow table.

- For logs, if you output logs other than console output, they should all be in logs.

Briefly introduce the code in this switch:
- One thing here is the `BitArray` type, which is actually equivalent to a variable-length bitset. Bit arrays of network order with different functions can be constructed through different constructors, and there should be application cases for it in the test code. It can be constructed through an immediate value, or through a network packet (of course, I later found out that this problem was indeed my concern, but I wrote it all, so I didn't continue to think about how to change it back).

- Then there are the four layers and the pipeline, which are formed based on the transformation of the previous [code](https://github.com/jijinfanhua/IPSA-ipbm/tree/main/sw-src), nothing.

- Then there is the `main function`. A lot of the codes of the main function is specially written for presentation, and the output is **colorful**.