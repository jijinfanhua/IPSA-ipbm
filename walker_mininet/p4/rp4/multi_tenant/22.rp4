header ethernet_t {
	bit<48>	dst_address;
	bit<48>	src_address;
	bit<16>	ether_type;
}
header ipv4_t {
	bit<4>	version;
	bit<4>	ihl;
	bit<8>	type_service;
	bit<16>	total_length;
	bit<16>	identification;
	bit<3>	flags;
	bit<13>	fragment_offset;
	bit<8>	ttl;
	bit<8>	protocol;
	bit<16>	header_checksum;
	bit<32>	src_address;
	bit<32>	dst_address;
}
header calculate_t {
	bit<32>	a0;
	bit<32>	a1;
	bit<32>	a2;
	bit<32>	a3;
	bit<32>	a4;
	bit<32>	a5;
	bit<32>	a6;
	bit<32>	a7;
}
struct metadata {
	bit<1>	tmp;
} meta;
struct headers {
	ethernet_t	ethernet;
	ipv4_t	ipv4;
	calculate_t	calculate;
} hdr;

struct standard_metadata_t {
    bit<9> ingress_port;
    bit<9> egress_spec;
    bit<9> egress_port;
    bit<32> clone_spec;
    bit<32> instance_type;
    bit<1> drop;
    bit<16> recirculate_port;
    bit<32> packet_length;
} standard_metadata;

parser MyParser(packet_in packet) {
	state start {
		packet.extract(hdr.ethernet);
		transition select(hdr.ethernet.ether_type) {
			0x0800: parse_ipv4;
			default: accept;
		}
	}
	state parse_ipv4 {
		packet.extract(hdr.ipv4);
		transition select(hdr.ipv4.protocol) {
			0xc8: parse_calculate;
			0xc9: parse_calculate;
			default: accept;
		}
	}
	state parse_calculate {
		packet.extract(hdr.calculate);
		transition accept;
	}
}

actions {
	action NoAction() {
	}
	action drop_1() {
		standard_metadata.drop = 1;
	}
	action drop_2() {
		standard_metadata.drop = 1;
	}
	action drop_3() {
		standard_metadata.drop = 1;
	}
	action drop_4() {
	    standard_metadata.drop = 1;
	}
	action add_action() {
		hdr.calculate.a0 = ((hdr.calculate.a0 + hdr.calculate.a2) & 0xffffffff);
		hdr.calculate.a1 = ((hdr.calculate.a1 + hdr.calculate.a3) & 0xffffffff);
	}
	action and_action() {
		hdr.calculate.a0 = (hdr.calculate.a0 & hdr.calculate.a2);
		hdr.calculate.a1 = (hdr.calculate.a1 & hdr.calculate.a3);
	}
	action forward(bit<48> src_address, bit<48> dst_address, bit<9> port) {
		standard_metadata.egress_spec = port;
		hdr.ethernet.src_address = src_address;
		hdr.ethernet.dst_address = dst_address;
	}
	action act() {
		meta.tmp = true;
	}
	action act_0() {
		meta.tmp = false;
	}
	action dest_check__HIT__() {
	}
	action dest_check__MISS__() {
	}
}

tables {
	table dest_check {
		key = {
			hdr.ethernet.dst_address: exact;
		}
		size = 1024;
		value_width = 16;
		default_action = dest_check__MISS__;
	}
	table tbl_act {
		key = {
		}
		size = 1024;
		value_width = 16;
		default_action = act;
	}
	table tbl_act_0 {
		key = {
		}
		size = 1024;
		value_width = 16;
		default_action = act_0;
	}
	table ip_forward {
		key = {
			hdr.ipv4.dst_address: lpm;
		}
		size = 1024;
		value_width = 121;
		default_action = drop_1;
	}
	table tbl_add_action {
		key = {
		}
		size = 1024;
		value_width = 16;
		default_action = add_action;
	}
	table tbl_and_action {
		key = {
		}
		size = 1024;
		value_width = 16;
		default_action = and_action;
	}
	table tbl_drop {
		key = {
		}
		size = 1024;
		value_width = 16;
		default_action = drop_3;
	}
    table tbl_drop_2 {
        key = {
        }
        size = 1024;
        value_width = 16;
        default_action = drop_4;
    }
}

control MyIngress {
	stage node_2 {
		parser {
			ethernet;
			ipv4;
		};
		matcher {
			switch (hdr.ipv4.isValid()) {
				0b1: table(dest_check);
				*: table(tbl_drop);
			}
		};
		executor {
			dest_check__HIT__: tbl_act_s;
			dest_check__MISS__: tbl_act_0_s;
			drop_3: None;
		};
	}
	stage node_6 {
		parser {
			ipv4;
		};
		matcher {
			switch (meta.tmp) {
				0b1: table(ip_forward);
				*: None;
			}
		};
		executor {
			drop_1: node_8;
			forward: node_8;
		};
	}
	stage node_8 {
		parser {
			ipv4;
			calculate;
		};
		matcher {
			switch ((hdr.ipv4.protocol == 0xc8)) {
				0b1: table(tbl_add_action);
				*: stage(node_10);
			}
		};
		executor {
			add_action: None;
		};
	}
	stage node_10 {
		parser {
			ipv4;
			calculate;
		};
		matcher {
			switch ((hdr.ipv4.protocol == 0xc9)) {
				0b1: table(tbl_and_action);
				*: table(tbl_drop_2);
			}
		};
		executor {
			and_action: None;
			drop_4: None;
		};
	}
	stage tbl_act_s {
		parser {
		};
		matcher {
			switch (1) {
				0b1: table(tbl_act);
			}
		};
		executor {
			act: node_6;
		};
	}
	stage tbl_act_0_s {
		parser {
		};
		matcher {
			switch (1) {
				0b1: table(tbl_act_0);
			}
		};
		executor {
			act_0: node_6;
		};
	}
}
control MyEgress {
}

