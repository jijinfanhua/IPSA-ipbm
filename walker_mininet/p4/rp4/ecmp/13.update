header ethernet_t {
	bit<48>	dst_address;
	bit<48>	src_address;
	bit<16>	ether_type;
}
header ipv4_t {
	bit<4>	version;
	bit<4>	ihl;
	bit<8>	type_service;
	bit<16>	total_length;
	bit<16>	identification;
	bit<3>	flags;
	bit<13>	fragment_offset;
	bit<8>	ttl;
	bit<8>	protocol;
	bit<16>	header_checksum;
	bit<32>	src_address;
	bit<32>	dst_address;
}
header icmp_t {
	bit<64>	icmp_content;
	bit<6>	remain_field;
	bit<2>	   hash_code;
}
struct metadata {
	bit<1>	tmp;
} meta;
struct headers {
	ethernet_t	ethernet;
	ipv4_t	ipv4;
	icmp_t	icmp;
} hdr;

struct standard_metadata_t {
    bit<9> ingress_port;
    bit<9> egress_spec;
    bit<9> egress_port;
    bit<32> clone_spec;
    bit<32> instance_type;
    bit<1> drop;
    bit<16> recirculate_port;
    bit<32> packet_length;
} standard_metadata;

parser MyParser(packet_in packet) {
	state start {
		packet.extract(hdr.ethernet);
		transition select(hdr.ethernet.ether_type) {
			0x0800: parse_ipv4;
			default: accept;
		}
	}
	state parse_ipv4 {
		packet.extract(hdr.ipv4);
		transition parse_icmp;
	}
	state parse_icmp {
	    packet.extract(hdr.icmp);
	    transition accept;
	}

}

add action
	action NoAction_1() {
	}
add action
	action NoAction_2() {
	}
add action
    action NoAction_3() {
    }
add action
	action load_balance(bit<48> src_address, bit<48> dst_address, bit<9> port) {
	    standard_metadata.egress_spec = port;
	    hdr.ethernet.src_address = src_address;
	    hdr.ethernet.dst_address = dst_address;
	}

add table
	table egress_check {
	    key = {
	        standard_metadata.egress_spec: exact;
	    }
	    size = 1024;
	    value_width = 16;
	    default_action = NoAction_2;
	}
add table
	table ecmp {
		key = {
			hdr.icmp.hash_code: exact;
		}
		size = 1024;
		value_width = 25;
		default_action = NoAction_1;
	}

add stage
	stage check {
	    parser {};
	    matcher {
	        switch (1) {
	            0b1: table(egress_check);
	        }
	    };
	    executor {
	        NoAction_3: ecmp_s;
	        NoAction_2: None;
	    };
	}
add stage
	stage ecmp_s {
		parser {
			icmp;
		};
		matcher {
			switch (1) {
				0b1: table(ecmp);
			}
		};
		executor {
			NoAction_1: None;
			load_balance: None;
		};
	}

rebuild action_to_stage forward in stage node_6 next_stage check